// This is your Prisma schema file
// Schema matches database.md exactly (SINGLE SOURCE OF TRUTH)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS (from database.md Section 3)
// ============================================

enum ResumeVersionType {
  BASE
  MANUAL
  AI_GENERATED
}

enum ResumeVersionStatus {
  DRAFT
  COMPILED
  ERROR
  ACTIVE
}

enum ResumeSectionType {
  EDUCATION
  EXPERIENCE
  PROJECTS
  SKILLS
  ACHIEVEMENTS
  OTHER
}

enum AIJobStatus {
  QUEUED
  RUNNING
  COMPLETED
  FAILED
}

enum AIMode {
  MINIMAL
  BALANCED
  AGGRESSIVE
}

enum AIModelProvider {
  DEEPSEEK
  AZURE_OPENAI
  GEMINI
}

// ============================================
// MODELS (from database.md Section 4)
// ============================================

/// User (database.md Section 4.1)
/// Represents an authenticated user
/// Authentication is handled externally (Clerk)
model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique
  email     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  projects ResumeProject[]
  apiKeys  UserAPIKey[]
}

/// ResumeProject (database.md Section 4.2)
/// Top-level container for resumes
/// One project = one resume strategy (e.g., "Backend Resume")
model ResumeProject {
  id        String   @id @default(uuid())
  userId    String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user            User             @relation(fields: [userId], references: [id])
  versions        ResumeVersion[]
  jobDescriptions JobDescription[]
  aiJobs          AIJob[]
}

/// ResumeVersion (database.md Section 4.3)
/// Represents a single version of a resume
/// Rules:
/// - Versions are NEVER overwritten
/// - AI always creates a new version
/// - parentVersionId enables version trees
/// - Only ONE ACTIVE version per project (enforced by unique constraint)
///
/// PHASE 2 HARDENING: onDelete behavior explicit
/// - Restrict on project: Cannot delete project with versions
/// - Restrict on parentVersion: Cannot delete version with children
model ResumeVersion {
  id              String              @id @default(uuid())
  projectId       String
  parentVersionId String?
  type            ResumeVersionType
  status          ResumeVersionStatus
  latexContent    String              @db.Text
  pdfUrl          String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  // Relations with explicit delete behavior
  project       ResumeProject   @relation(fields: [projectId], references: [id], onDelete: Restrict)
  parentVersion ResumeVersion?  @relation("VersionTree", fields: [parentVersionId], references: [id], onDelete: Restrict)
  childVersions ResumeVersion[] @relation("VersionTree")
  sections      ResumeSection[]
  aiJobs        AIJob[]
  diffsFrom     VersionDiff[]   @relation("DiffFrom")
  diffsTo       VersionDiff[]   @relation("DiffTo")

  // Indexes for query performance
  @@index([projectId, status])
}

/// ResumeSection (database.md Section 4.4)
/// Logical sections extracted from a resume version
/// Purpose:
/// - Section-wise AI control
/// - Locking for safety
/// - Cleaner diffs
///
/// PHASE 2 HARDENING: onDelete Restrict on version relation
model ResumeSection {
  id          String            @id @default(uuid())
  versionId   String
  sectionType ResumeSectionType
  content     String            @db.Text
  isLocked    Boolean
  orderIndex  Int
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relations with explicit delete behavior
  version ResumeVersion @relation(fields: [versionId], references: [id], onDelete: Restrict)

  // Ensure unique section types per version + efficient queries
  @@unique([versionId, sectionType])
  @@index([versionId, orderIndex])
}

/// JobDescription (database.md Section 4.5)
/// Stores job descriptions and extracted intelligence
/// Notes:
/// - AI analysis output is stored, not recomputed
/// - JSON is flexible by design
///
/// PHASE 2 HARDENING: onDelete Restrict on project relation
model JobDescription {
  id              String   @id @default(uuid())
  projectId       String
  rawText         String   @db.Text
  extractedSkills Json
  keywords        Json
  roleType        String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations with explicit delete behavior
  project ResumeProject @relation(fields: [projectId], references: [id], onDelete: Restrict)
  aiJobs  AIJob[]
}

/// AIJob (database.md Section 4.6)
/// Tracks asynchronous AI operations
/// Rules:
/// - Frontend polls job status
/// - No synchronous AI calls
///
/// PHASE 2 HARDENING: onDelete Restrict on all foreign key relations
/// CHAT MODE: jdId is now optional to support chat-based editing without JD
model AIJob {
  id            String      @id @default(uuid())
  projectId     String
  baseVersionId String
  jdId          String?
  mode          AIMode
  status        AIJobStatus
  errorMessage  String?     @db.Text
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations with explicit delete behavior
  project         ResumeProject    @relation(fields: [projectId], references: [id], onDelete: Restrict)
  baseVersion     ResumeVersion    @relation(fields: [baseVersionId], references: [id], onDelete: Restrict)
  jd              JobDescription?  @relation(fields: [jdId], references: [id], onDelete: Restrict)
  proposedVersion ProposedVersion? // 1:1 relation (optional)
}

/// ProposedVersion (database.md Section 4.7)
/// Stores AI-generated resume proposals before user acceptance
/// Purpose:
/// - Temporary storage for AI output
/// - User can review before accepting
/// - Not a ResumeVersion until accepted
/// - Deleted or overwritten on new proposal
///
/// Rules:
/// - One proposal per AIJob
/// - Must NOT be auto-applied to editor
/// - User must explicitly accept to create ResumeVersion
///
/// GOAL 3: Enhanced for section-level proposals
/// - sectionProposals: JSON array of {sectionType, before, after}
/// - proposedLatexContent: Full assembled LaTeX (for backward compatibility)
/// - Section-aware diffs enable granular accept/reject
model ProposedVersion {
  id                    String   @id @default(uuid())
  aiJobId               String   @unique
  proposedLatexContent  String   @db.Text
  sectionProposals      Json     @default("[]")
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations with explicit delete behavior
  aiJob AIJob @relation(fields: [aiJobId], references: [id], onDelete: Cascade)
}

/// VersionDiff (database.md Section 4.7)
/// Explains differences between resume versions
/// Purpose:
/// - Transparency
/// - Trust
/// - Diff UI
///
/// PHASE 2 HARDENING: onDelete Restrict on version relations
model VersionDiff {
  id            String   @id @default(uuid())
  fromVersionId String
  toVersionId   String
  added         Json
  removed       Json
  rewritten     Json
  createdAt     DateTime @default(now())

  // Relations with explicit delete behavior
  fromVersion ResumeVersion @relation("DiffFrom", fields: [fromVersionId], references: [id], onDelete: Restrict)
  toVersion   ResumeVersion @relation("DiffTo", fields: [toVersionId], references: [id], onDelete: Restrict)
}

/// UserAPIKey (database.md Section 4.8)
/// Stores user's AI model provider API keys
/// Purpose:
/// - Store user's personal AI provider credentials
/// - Enable model selection (DeepSeek vs Azure OpenAI)
/// - Validate API keys before use
///
/// Rules:
/// - One key per provider per user
/// - API keys are stored as plain strings (encryption at transport layer)
/// - isValid tracks last validation status
/// - validationError stores last error message if invalid/expired
/// - endpoint allows custom Azure OpenAI endpoint URLs
///
/// Notes:
/// - AZURE_OPENAI requires: apiKey + endpoint
/// - DEEPSEEK uses system-wide Nebius credentials (no user key needed)
model UserAPIKey {
  id               String            @id @default(uuid())
  userId           String
  provider         AIModelProvider
  apiKey           String
  endpoint         String?
  isValid          Boolean           @default(true)
  lastValidated    DateTime?
  validationError  String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
}
